;;; llm-tool-collection.el --- Crowdsourced tools for LLMs -*- lexical-binding: t -*-

;; Author: Ad <me@skissue.xyz>
;; Maintainer: Ad <me@skissue.xyz>
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))
;; Homepage: https://github.com/skissue/llm-tool-collection
;; Keywords: tools, convenience


;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; Crowdsourced collection of tools for LLMs in Emacs

;;; Code:

(require 'seq)

(defvar llm-tool-collection--all-tools nil
  "A list of all tool definition symbols.")

(defun llm-tool-collection--name-to-symbol (name)
  "Convert tool NAME into a namespaced symbol by prepending `llm-tc/'."
  (intern (concat "llm-tc/" (symbol-name name))))

(defun llm-tool-collection--make-llm-name (name)
  "Replace dashes with underscores to make tool NAME LLM-friendly."
  (string-replace "-" "_" (symbol-name name)))

(defmacro llm-tool-collection-deftool (name specs args &rest body)
  "Declare a generic LLM tool named NAME.
SPECS should be a plist specifying the standard attributes of an LLM
tool.  The `:name' attribute should be set to an LLM-friendly name.  If
it is not set, the NAME argument (with dashes replaced with underscores)
will be used by default.

SPECS may also contain extra keywords used by certain clients, such as
`:include' and `:confirm' for gptel. Conformant clients should ignore
all unsupported keywords. Tool definitions should contain a `:category'
value and a list of symbols for `:tags' to make it convenient for users
to select tools.

ARGS is a list where each element is of the form

  (ARGNAME :type TYPE :description \"DESCRIPTION\").

Arguments after the special symbol `&optional' are marked with
`:optional t`.

BODY contains the function body.

This macro creates a constant with the tool's specs and defines a
function under `llm-tc/NAME' whose docstring is the value of the spec
`:description'.  The constant with the tool spec is made available via
`llm-tool-collection-get-all' and `llm-tool-collection-get-category'."
  (declare (indent defun)
           (debug (&define symbolp sexp sexp def-body)))
  (let* ((optional nil)
         (arg-syms '())
         (arg-specs '()))
    (dolist (arg args)
      (if (eq arg '&optional)
          (progn
            (setq optional t)
            (push arg arg-syms))
        (let ((argname (car arg))
              (argrest (cdr arg)))
          (push argname arg-syms)
          (push `(:name ,(llm-tool-collection--make-llm-name argname)
                        ,@(when optional '(:optional t))
                        ,@argrest)
                arg-specs))))
    (setq arg-syms (reverse arg-syms)
          arg-specs (reverse arg-specs))
    (let* ((sym (llm-tool-collection--name-to-symbol name))
           (name (unless (plist-get specs :name)
                   `(:name ,(llm-tool-collection--make-llm-name name)))))
      `(progn
         (defconst ,sym
           '(,@name
             ,@specs
             :args ,arg-specs
             :function #',sym))
         (defun ,sym ,arg-syms
           ,(concat (plist-get specs :description) "\n\n"
                    "Definition generated by `llm-tool-collection'.")
           ,@body)
         (push ',sym llm-tool-collection--all-tools)))))


(defun llm-tool-collection-get-category (category)
  "Return a list of all tool definitions in the collection part of CATEGORY.

Mapping over this list with `gptel-make-tool', `llm-make-tool', or
similar will add all tools to the respective client:

 (mapcar (apply-partially #'apply #'gptel-make-tool)
         (llm-tool-collection-get-category \"filesystem\"))"
  (seq-filter (lambda (tool) (string= (plist-get tool :category) category))
              (llm-tool-collection-get-all)))

(defun llm-tool-collection-get-all ()
  "Return a list of all tool definitions in the collection.

Mapping over this list with `gptel-make-tool', `llm-make-tool', or
similar will add all tools to the respective client:

 (mapcar (apply-partially #'apply #'gptel-make-tool)
         (llm-tool-collection-get-all))"
  (mapcar #'symbol-value llm-tool-collection--all-tools))

(llm-tool-collection-deftool read-file
  (:description
   "Read the contents of a file and return its content as a string."
   :category "filesystem"
   :confirm t
   :include t)
  ((path
    :type string
    :description "Path to the file to read. Supports relative paths and '~'."))
  (with-temp-buffer
    (insert-file-contents (expand-file-name path))
    (buffer-string)))

(llm-tool-collection-deftool list-directory
  (:description "List the contents of a specified directory."
                :category "filesystem"
                :confirm t
                :include t)
  ((path
    :type string
    :description "Path to the directory. Supports relative paths and '~'."))
  (let ((expanded-path (expand-file-name path)))
    (if (file-directory-p expanded-path)
        (string-join `(,(format "Contents of %s:" path)
                       ,@(directory-files expanded-path))
                     "\n")
      (error "%s is not a directory" expanded-path))))

(llm-tool-collection-deftool create-file
  (:description
   "Create a new file with the specified content if it does not already exist."
   :category "filesystem"
   :confirm t)
  ((path
    :type string
    :description "Path to the new file. Supports relative paths and '~'.")
   (content :type string :description "Content to write to the file."))
  (let ((expanded-path (expand-file-name path)))
    (if (file-exists-p expanded-path)
        (error "File already exists: %s" expanded-path)
      (with-temp-file expanded-path
        (insert content))
      (format "File created successfully: %s" path))))

(llm-tool-collection-deftool create-directory
  (:description
   "Create a new directory at the specified path if it does not already exist."
   :category "filesystem"
   :confirm t)
  ((path
    :type string
    :description "Path to the new directory. Supports relative paths and '~'."))
  (let ((expanded-path (expand-file-name path)))
    (if (file-exists-p expanded-path)
        (error "Directory already exists: %s" expanded-path)
      (make-directory expanded-path t)
      (format "Directory created successfully: %s" path))))

(llm-tool-collection-deftool view-buffer
  (:description "View contents of BUFFER-NAME with optional OFFSET and LIMIT.
OFFSET specifies the starting line (0-based).
LIMIT specifies the maximum number of lines to return."
                :category "buffers")
  ((buffer-name :type string :description "Name of the buffer to view.")
   &optional
   (offset :type integer :description "Line number to start reading from (0-based).")
   (limit :type integer :description "Maximum number of lines to return."))
  (with-current-buffer buffer-name
    (let* ((lines (split-string (buffer-string) "\n"))
           (total-lines (length lines))
           (start (min (or offset 0) total-lines))
           (end (min (+ start (or limit total-lines)) total-lines))
           (selected-lines (seq-subseq lines start end)))
      (string-join selected-lines "\n"))))

(provide 'llm-tool-collection)

;;; llm-tool-collection.el ends here
